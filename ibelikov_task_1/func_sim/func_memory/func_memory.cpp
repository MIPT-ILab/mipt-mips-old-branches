/**
 * func_memory.cpp - the module implementing the concept of
 * programer-visible memory space accesing via memory address.
 * @author Alexander Titov <alexander.igorevich.titov@gmail.com>
 * Implementation of memory methods:
 * @author Ilya Belikov <ilya.i.belikov@gmail.com>
 * Copyright 2012-2014 uArchSim iLab project
 */

// Generic C

// Generic C++

// uArchSim modules
#include <func_memory.h>
#include <iostream>
#include <string.h>
#include <stdlib.h>
#include <sstream>

FuncMemory::FuncMemory( const char* executable_file_name,
                        uint64 addr_size,
                        uint64 page_bits,
                        uint64 offset_bits)
{
    // init address parts sizes
    SetSize = addr_size - page_bits - offset_bits;
    PageSize = page_bits;
    OffsetSize = offset_bits;

    assert( executable_file_name);
    assert( addr_size);
    assert( page_bits);
    assert( offset_bits);

    // read data from ELF file
    vector<ElfSection> sections_array;
    ElfSection::getAllElfSections( executable_file_name, sections_array);

    text_start_addr = 0;
    start_addr = 0;

    for( uint64 section = 0; section < sections_array.size(); ++section)
    {
        if( strcmp( sections_array[ section].name, ".text") == 0)
            text_start_addr = sections_array[ section].start_addr;

        for( uint64 i = 0; i < sections_array[ section].size/4; ++i)
        {
            uint64 address = sections_array[ section].start_addr + i;
            uint64 value = *( uint32*)( sections_array[ section].content + i);
            write( value, address, 4);
            if( (section == 0) && (i == 0)) start_addr = address;
        }
    }
}

FuncMemory::~FuncMemory()
{
    //delete &Memory;
}

/**
 * Method startPC() returns start address of ".text" block
 */
uint64 FuncMemory::startPC() const
{
    return text_start_addr;
}

/**
 * Method returnSet takes address and returns set subaddress generated by
 * address parsing rules of this FuncMemory object using subaddress blocks sizes
 */
uint64 FuncMemory::returnSet( uint64 addr) const
{
    return (addr & ( ~( uint32)0 << ( PageSize + OffsetSize)))
                                    >> ( PageSize + OffsetSize);
}

/**
 * Method returnPage takes address and returns page subaddress generated by
 * address parsing rules of this FuncMemory object using subaddress blocks sizes
 */
uint64 FuncMemory::returnPage( uint64 addr) const
{
    return ( addr & ( ~( uint32)0 >> SetSize)) >> OffsetSize;
}

/**
 * Method returnOffset takes address and returns Offset subaddress generated by
 * address parsing rules of this FuncMemory object using subaddress blocks sizes
 */
uint64 FuncMemory::returnOffset( uint64 addr) const
{
    return ( addr & ( ~( uint32)0 >> ( SetSize + PageSize)));
}

/**
 * Private method for reading byte sequence. Input values must be verifyed
 * before calling this method. Method reads byte sequence that located at
 * common offset address space (bytes are destinated at one set and page)
 */
void FuncMemory::read_s( uint8* data, uint64 addr, unsigned short num_of_bytes) const
{
    map< uint64, const void*>::const_iterator it;

    uint64 Set_addr = returnSet( addr);
    uint64 Page_addr = returnPage( addr);
    uint64 Offset_addr = returnOffset( addr);

    it = Memory.find( Set_addr);

    it = ( ( map<uint64, const void*>*)( it->second))->
                                        find( Page_addr);

    for( int i = 0; i < num_of_bytes; ++i)
            data[ i] = ( ( map< uint64, uint8>*)( it->second))->find( Offset_addr + i)->second;
}

/**
 * Public method for reading byte sequence. Method reads byte sequence
 * which length is num_of_bytes from start address addr and return it
 * in uint64 format.
 */
uint64 FuncMemory::read( uint64 addr, unsigned short num_of_bytes) const
{
    assert( num_of_bytes != 0);
    assert( num_of_bytes <= 8);
    assert( returnSet(addr));

    uint64 ret = 0;

    int start_s = 0, end_s = 0;

    while( start_s < num_of_bytes)
    {
        uint64 comp = returnOffset( addr + start_s);
        end_s++;
        while ( ( end_s < num_of_bytes) &&
                ( returnOffset( addr + end_s) > returnOffset( addr + end_s - 1)))
        {
            end_s++;
        }
        read_s( ( uint8*)&ret + start_s, addr + start_s, end_s - start_s);
        start_s = end_s;
    }

    return ret;
}

/**
 * Private method for writing byte sequence. Input values must be verifyed
 * before calling this method. Method writes byte sequence that located at
 * common offset address space (bytes are destinated at one set and page)
 */
void FuncMemory::write_s( uint8* data, uint64 addr, unsigned short num_of_bytes)
{
    pair< map< uint64, const void*>::iterator, bool > ret;

    uint64 Set_addr = returnSet( addr);
    uint64 Page_addr = returnPage( addr);
    uint64 Offset_addr = returnOffset( addr);

    ret = Memory.insert(
                    pair< uint64, const void*>
                    ( Set_addr, ( const void*)( new map<uint64, const void*>))
                );

    ret = ( ( map< uint64, const void*>*)( ret.first->second))->
                insert(
                    pair< uint64, const void*>
                    ( Page_addr, ( const void*)( new map<uint64, uint8>))
                );

    map< uint64, uint8>* dest = ( ( map< uint64, uint8>*)( ret.first->second));

    for( int i = 0; i < num_of_bytes; ++i)
    {
        dest->erase( Offset_addr + i);
        dest->insert( pair< uint64, uint8>( Offset_addr + i, *( data + i)));
    }
}

/**
 * Public method for writing byte sequence. Method writes byte sequence
 * called value which length is num_of_bytes from start address addr.
 */
void FuncMemory::write( uint64 value, uint64 addr, unsigned short num_of_bytes)
{
    assert( num_of_bytes != 0);
    assert( num_of_bytes <= sizeof( uint64));

    uint8 *data = ( uint8*)&value;
    int start_s = 0, end_s = 0;

    while( start_s < num_of_bytes)
    {
        uint64 comp = returnOffset( addr + start_s);
        end_s++;
        while ( ( end_s < num_of_bytes) &&
                ( returnOffset( addr + end_s) > returnOffset( addr + end_s - 1)))
        {
            end_s++;
        }
        write_s( data + start_s, addr + start_s, end_s - start_s);
        start_s = end_s;
    }
}

string FuncMemory::Pagedump( string indent, const void* pointer)
{
    ostringstream oss;

    map< uint64, uint8>* this_ = ( map< uint64, uint8>*)pointer;

    oss << indent << "Content: " << endl;

    std::map< uint64, uint8>::iterator it = this_->begin();

    while(it != this_->end())
    {
        uint64 data = 0;
        int i = 0;
        while( ( i < 4)&&( it != this_->end()))
        {
            data = ( data << 8) | (uint32)it->second;
            it++;
            i++;
        }
        oss << indent << "0x" << hex;
        oss.width( 8);
        oss.fill( '0');
        oss << it->first << ": 0x" << hex;
        oss.width( 8);
        oss.fill( '0');
        oss << data << dec << endl;
    }

    return oss.str();
}

string FuncMemory::Setdump( string indent, const void* pointer)
{
    ostringstream oss;

    map< uint64, const void*>* this_ = ( map< uint64, const void*>*)pointer;

    for( std::map< uint64, const void*>::iterator it = this_->begin(); it != this_->end(); it++)
    {
        oss << indent << "Page: 0x" << hex;
        oss.width( 8);
        oss.fill( '0');
        oss << it->first << dec << endl
            << indent << Pagedump( indent, it->second) << dec << endl;
    }

    return oss.str();
}

/**
 * Method dump returns memory dump in string
 */
string FuncMemory::dump( string indent)
{
    ostringstream oss;

    for( std::map< uint64, const void*>::iterator it = Memory.begin(); it != Memory.end(); it++)
    {
        oss << indent << "Set: 0x" << hex;
        oss.width( 8);
        oss.fill( '0');
        oss << it->first << dec << endl
            << indent << Setdump( indent, it->second) << dec << endl;
    }

    return oss.str();
}
